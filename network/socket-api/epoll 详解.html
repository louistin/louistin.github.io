<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>epoll 详解 | 🔞の領域</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/image/favicon.png">
    <meta name="description" content="　我们立足于美利坚合众国, 针对年满18周岁非大陆全球华人开发, 受北美法律保护.　 　　　　　　　　　　　　　未經授權禁止复制或建立镜像. 　　　　　　　　　　　　We are based in the United States of America, for over 18 years of age non-mainland Chinese open world, by the North American legal protection. Unauthorized reproduction prohibited or create mirror.">
    <link rel="preload" href="/assets/css/0.styles.eda1073d.css" as="style"><link rel="preload" href="/assets/js/app.5aa78949.js" as="script"><link rel="preload" href="/assets/js/2.db8a1bd9.js" as="script"><link rel="preload" href="/assets/js/27.d86ae0b6.js" as="script"><link rel="prefetch" href="/assets/js/10.cb22b5cc.js"><link rel="prefetch" href="/assets/js/11.7fc433a5.js"><link rel="prefetch" href="/assets/js/12.26e9cadb.js"><link rel="prefetch" href="/assets/js/13.1258d0f5.js"><link rel="prefetch" href="/assets/js/14.99ec5e93.js"><link rel="prefetch" href="/assets/js/15.5e075e9b.js"><link rel="prefetch" href="/assets/js/16.3ae89ebf.js"><link rel="prefetch" href="/assets/js/17.a0578cc8.js"><link rel="prefetch" href="/assets/js/18.57573e35.js"><link rel="prefetch" href="/assets/js/19.1921cef9.js"><link rel="prefetch" href="/assets/js/20.21e6a458.js"><link rel="prefetch" href="/assets/js/21.85d787bf.js"><link rel="prefetch" href="/assets/js/22.463f771e.js"><link rel="prefetch" href="/assets/js/23.a24c9494.js"><link rel="prefetch" href="/assets/js/24.4e9dffaf.js"><link rel="prefetch" href="/assets/js/25.48966cca.js"><link rel="prefetch" href="/assets/js/26.79a3a1f7.js"><link rel="prefetch" href="/assets/js/28.3085660e.js"><link rel="prefetch" href="/assets/js/29.b25e9aa3.js"><link rel="prefetch" href="/assets/js/3.bfe9edf0.js"><link rel="prefetch" href="/assets/js/30.32eb4625.js"><link rel="prefetch" href="/assets/js/31.c255a7cd.js"><link rel="prefetch" href="/assets/js/32.d4a5e1b3.js"><link rel="prefetch" href="/assets/js/33.939416f6.js"><link rel="prefetch" href="/assets/js/34.1527656e.js"><link rel="prefetch" href="/assets/js/35.31254244.js"><link rel="prefetch" href="/assets/js/36.4c9eea64.js"><link rel="prefetch" href="/assets/js/37.dcba8e22.js"><link rel="prefetch" href="/assets/js/38.660f4f18.js"><link rel="prefetch" href="/assets/js/39.36808ac4.js"><link rel="prefetch" href="/assets/js/4.721e6361.js"><link rel="prefetch" href="/assets/js/40.5e3d825d.js"><link rel="prefetch" href="/assets/js/41.8bc35558.js"><link rel="prefetch" href="/assets/js/42.3d9ee979.js"><link rel="prefetch" href="/assets/js/43.d8a9355a.js"><link rel="prefetch" href="/assets/js/44.3b96fdab.js"><link rel="prefetch" href="/assets/js/45.5a397a89.js"><link rel="prefetch" href="/assets/js/46.2c015a12.js"><link rel="prefetch" href="/assets/js/47.cb620ad3.js"><link rel="prefetch" href="/assets/js/48.63e77fd7.js"><link rel="prefetch" href="/assets/js/49.3a1743f4.js"><link rel="prefetch" href="/assets/js/5.9c8aa7de.js"><link rel="prefetch" href="/assets/js/50.858e22ae.js"><link rel="prefetch" href="/assets/js/51.d5ea8da3.js"><link rel="prefetch" href="/assets/js/6.cfcb9227.js"><link rel="prefetch" href="/assets/js/7.7ef2cd09.js"><link rel="prefetch" href="/assets/js/8.8cae79fc.js"><link rel="prefetch" href="/assets/js/9.116ce45e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.eda1073d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">🔞の領域</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/network/" class="nav-link router-link-active">
  网络编程
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  后端开发
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  前端开发
</a></div><div class="nav-item"><a href="/opensource/" class="nav-link">
  开源软件
</a></div><div class="nav-item"><a href="/note/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/manual/" class="nav-link">
  开发手册
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/louistin/blog.liteman.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/network/" class="nav-link router-link-active">
  网络编程
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  后端开发
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  前端开发
</a></div><div class="nav-item"><a href="/opensource/" class="nav-link">
  开源软件
</a></div><div class="nav-item"><a href="/note/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/manual/" class="nav-link">
  开发手册
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/louistin/blog.liteman.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TCP/IP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Socket API</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/network/socket-api/epoll 详解.html" class="active sidebar-link">epoll 详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/socket-api/epoll 详解.html#数据的接收" class="sidebar-link">数据的接收</a></li><li class="sidebar-sub-header"><a href="/network/socket-api/epoll 详解.html#同时监听多个-socket-的简单方法" class="sidebar-link">同时监听多个 Socket 的简单方法</a></li><li class="sidebar-sub-header"><a href="/network/socket-api/epoll 详解.html#epoll-设计思路" class="sidebar-link">epoll 设计思路</a></li><li class="sidebar-sub-header"><a href="/network/socket-api/epoll 详解.html#epoll-原理和流程" class="sidebar-link">epoll 原理和流程</a></li><li class="sidebar-sub-header"><a href="/network/socket-api/epoll 详解.html#epoll-实现细节" class="sidebar-link">epoll 实现细节</a></li><li class="sidebar-sub-header"><a href="/network/socket-api/epoll 详解.html#参考资料" class="sidebar-link">参考资料</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>IPC</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="epoll-详解"><a href="#epoll-详解" class="header-anchor">#</a> epoll 详解</h1> <blockquote><p align="left" style="font-family:Arial;font-size:80%;color:#C0C0C0;">全文字数 912 words  |  阅读时间 5 mins</p>
综合网络上关于 epoll 相关文章, 梳理 epoll 本质
</blockquote> <p></p><div class="table-of-contents"><ul><li><a href="#数据的接收">数据的接收</a><ul><li><a href="#网卡接收数据">网卡接收数据</a></li><li><a href="#中断信号通知-cpu">中断信号通知 CPU</a></li><li><a href="#操作系统进程调度处理数据">操作系统进程调度处理数据</a></li></ul></li><li><a href="#同时监听多个-socket-的简单方法">同时监听多个 Socket 的简单方法</a><ul><li><a href="#select">select()</a></li></ul></li><li><a href="#epoll-设计思路">epoll 设计思路</a><ul><li><a href="#功能分离">功能分离</a></li><li><a href="#就绪列表">就绪列表</a></li></ul></li><li><a href="#epoll-原理和流程">epoll 原理和流程</a><ul><li><a href="#创建-epoll-对象">创建 epoll 对象</a></li><li><a href="#维护监视列表">维护监视列表</a></li><li><a href="#接收数据">接收数据</a></li><li><a href="#阻塞和唤醒进程">阻塞和唤醒进程</a></li></ul></li><li><a href="#epoll-实现细节">epoll 实现细节</a></li><li><a href="#参考资料">参考资料</a></li></ul></div><p></p> <hr> <h2 id="数据的接收"><a href="#数据的接收" class="header-anchor">#</a> 数据的接收</h2> <h3 id="网卡接收数据"><a href="#网卡接收数据" class="header-anchor">#</a> 网卡接收数据</h3> <ul><li>网卡接收数据后, 将数据写入内存</li></ul> <h3 id="中断信号通知-cpu"><a href="#中断信号通知-cpu" class="header-anchor">#</a> 中断信号通知 CPU</h3> <ul><li>网卡将数据写入内存后, <strong>网卡向 CPU 发出一个中断信号, 内核就能知道有新数据到来</strong>, 再通过
<strong>网卡中断程序</strong>去处理数据</li></ul> <blockquote><p>中断</p> <ul><li>计算机执行程序时, 会有优先级要求. 由硬件产生的信号需要 CPU 立刻做出回应, 优先级很高.</li> <li>CPU 接收到中断信后后, 会立刻中断掉正在执行的程序, 做出响应; 当 CPU 完成对硬件的响应后,
再重新执行用户程序.</li> <li>中断的位置由信号决定</li> <li><strong>中断程序调用</strong><br><img src="/image/network/socket-api/001_epoll_interrupt.webp" alt="中断程序调用"></li></ul></blockquote> <h3 id="操作系统进程调度处理数据"><a href="#操作系统进程调度处理数据" class="header-anchor">#</a> 操作系统进程调度处理数据</h3> <ul><li>阻塞是进程调度的关键一环, 指的是进程在等待某事件(如接收到网络数据) 发生之前的等待状态,
<code>recv()</code>, <code>select()</code>, <code>epoll()</code> 都是阻塞方法.</li></ul> <h4 id="为什么进程阻塞不占用-cpu-资源"><a href="#为什么进程阻塞不占用-cpu-资源" class="header-anchor">#</a> 为什么进程阻塞不占用 CPU 资源</h4> <ul><li><p>工作队列</p> <ul><li>操作系统为支持多任务, 实现了进程调度功能, 会将进程分为 <strong>运行</strong> 和 <strong>等待</strong> 等几种状态
<ul><li>运行状态, 进程获得 CPU 使用权</li> <li>等待状态, 阻塞状态</li></ul></li> <li>A B C 三个进程都被操作系统工作队列引用, 处于运行态, 分时执行</li></ul> <p><strong>工作队列</strong><br><img src="/image/network/socket-api/001_epoll_workqueue.webp" alt="工作队列"></p></li> <li><p>等待队列</p> <ul><li>当进程 A 执行到 <code>socket()</code> 的语句时, 操作系统会创建一个由文件系统管理的 socket 对象.
这个 socket 对象包括可发送缓冲区, 接收缓冲区, 等待队列等成员.</li> <li>等待队列指向所有需要等待该 socket 事件的进程</li> <li>当程序执行到 <code>recv()</code> 时, 操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中(实
际是添加对这个进程的引用, 以便在接收到数据时获取进程对象, 将其唤醒), 此时工作队列只剩下
B C 两个进程, 依据进程调度, CPU 会轮流执行这两个进程的程序, 不会执行A 进程. 此时
<strong>A 进程被阻塞, 不会往下执行代码, 也不会占用 CPU 资源</strong></li></ul> <p><strong>Socket 创建</strong><br><img src="/image/network/socket-api/001_epoll_socket_create.webp" alt="Socket 创建"></p> <p><strong>等待队列</strong><br><img src="/image/network/socket-api/001_epoll_waitqueue.webp" alt="等待队列"></p></li> <li><p>唤醒进程</p> <ul><li>当 socket 接收到数据后, 操作系统将该 socket 等待队列上的进程重新放回到工作队列, 该进程
变为运行状态, 急促执行代码. 此时由于 socket 的接收缓冲区已经有了数据, <code>recv()</code> 可以返
回接收到的数据.</li></ul> <p><strong>唤醒进程</strong><br><img src="/image/network/socket-api/001_epoll_wakeup.webp" alt="唤醒进程"></p></li></ul> <p><strong>内核接收数据全过程</strong><br><img src="/image/network/socket-api/001_epoll_recv_data.webp" alt="内核接收数据全过程"></p> <blockquote><p>操纵系统根据网络数据包中的 IP:PORT 信息, 找到对应的 socket</p></blockquote> <h2 id="同时监听多个-socket-的简单方法"><a href="#同时监听多个-socket-的简单方法" class="header-anchor">#</a> 同时监听多个 Socket 的简单方法</h2> <p>服务器端需要管理多个客户端连接, <code>recv()</code> 只能监视单个 socket. <code>select()</code> 设计思想是, 预先
传入一个 socket 列表, 如果列表中的 socket 都没有数据, 挂起进程, 直到有一个 socket 收到数
据, 唤醒进程. 由此就能监视多个 socket.</p> <h3 id="select"><a href="#select" class="header-anchor">#</a> <code>select()</code></h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token function">listen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> fds<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  存放需要监听的socket<span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> fds<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fds<span class="token punctuation">.</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//fds[i]的数据处理</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li><p>select 流程</p> <ul><li>程序同时监视 sock1, sock2, sock3, 在调用 <code>select()</code> 后, 操作系统把进程 A 分别加入这
三个 socket 的等待队列中</li> <li>当任何一个 socket 接收到数据后, 中断程序将唤起进程, 将进程从所有等待队列中移除, 加入工作
队列</li> <li>当进程被唤醒后, 程序需要遍历一遍 socket 列表, 获取就绪的 socket</li></ul></li> <li><p>缺点</p> <ul><li>每次调用 <code>select()</code> 都需将进程加入到所有监视 socket 的等待队列, 每次唤醒都需要从每个队
列中移除. 这里涉及到两次遍历, 并且每次都要将整个 fds 列表传递给内核, 也有一定的开销. 所
以出于效率考量, select 默认的最大监视 socket 数为 FD_SETSIZE 1024</li> <li>进程被唤醒后, 程序并不知道哪些 socket 就绪, 需要再遍历一遍</li></ul> <p><strong>操作系统把进程 A 分别加入这三个 socket 的等待队列中</strong><br><img src="/image/network/socket-api/001_epoll_select_001.webp" alt="操作系统把进程 A 分别加入这三个 socket 的等待队列中"></p> <p><strong>sock2 接收到了数据, 中断程序唤起进程 A</strong><br><img src="/image/network/socket-api/001_epoll_select_002.webp" alt="sock2 接收到了数据, 中断程序唤起进程 A"></p> <p><strong>将进程 A 从所有等待队列中移除, 再加入到工作队列里面</strong><br><img src="/image/network/socket-api/001_epoll_select_003.webp" alt="将进程 A 从所有等待队列中移除, 再加入到工作队列里面"></p></li></ul> <h2 id="epoll-设计思路"><a href="#epoll-设计思路" class="header-anchor">#</a> epoll 设计思路</h2> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token function">listen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将所有需要监听的socket添加到epfd中</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>接收到数据的socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="功能分离"><a href="#功能分离" class="header-anchor">#</a> 功能分离</h3> <ul><li><p>select 中维护等待队列和阻塞进程两个步骤在一起, 每次调用都需要执行这两步操作.</p></li> <li><p>epoll 使用 <code>epoll_ctl()</code> <strong>维护等待队列</strong>, 再调用 <code>epoll_wait()</code> <strong>阻塞进程</strong>, 将这
两个步骤分开, 提升了效率</p> <p><strong>select epoll 对比</strong><br><img src="/image/network/socket-api/001_epoll_select_epoll.webp" alt="select epoll 对比"></p></li></ul> <h3 id="就绪列表"><a href="#就绪列表" class="header-anchor">#</a> 就绪列表</h3> <ul><li><p>select 中程序不知道哪些 socket 收到数据, 需要遍历</p></li> <li><p>epoll 中, 内核维护一个就绪列表 rdlist, 引用收到数据的 socket, 当进程被唤醒后, 只要获取
rdlist 内容, 就能够知道哪些 socket 收到数据</p> <p><strong>就绪列表</strong><br><img src="/image/network/socket-api/001_epoll_rdlist.webp" alt="就绪列表"></p></li></ul> <h2 id="epoll-原理和流程"><a href="#epoll-原理和流程" class="header-anchor">#</a> epoll 原理和流程</h2> <h3 id="创建-epoll-对象"><a href="#创建-epoll-对象" class="header-anchor">#</a> 创建 epoll 对象</h3> <ul><li><p>进程调用 <code>epoll_create()</code> 时, 内核会创建一个 eventpoll 对象(即 epfd 指向的对象).
eventpoll 是文件系统中的一员, 有自己的等待队列</p></li> <li><p>每一个 epoll 对象都有一个独立的 eventpoll 结构体, 用于存放通过 <code>epoll_ctl()</code> 添加进来
的事件. 这些事件都挂载在红黑树上, 重复添加事件时可以通过红黑树高效识别出来(红黑树插入效率
lgN, N 为树的高度)</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span><span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 红黑树的根节点, 这颗树中存储着所有添加到 epoll 中的需要监控的事件</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_root</span>  rbr<span class="token punctuation">;</span>
  <span class="token comment">// 双链表中则存放着将要通过 epoll_wait 返回给用户的满足条件的事件</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdlist<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>内核创建 eventpoll 对象</strong><br><img src="/image/network/socket-api/001_epoll_create_eventpoll.webp" alt="内核创建 eventpoll 对象"></p></li></ul> <h3 id="维护监视列表"><a href="#维护监视列表" class="header-anchor">#</a> 维护监视列表</h3> <ul><li><p>创建 epoll 对象后, 可以使用 <code>epoll_ctl()</code> 管理所要监听的 socket, 内核会将 eventpoll
添加到对应 socket 的等待队列, 或从所在的 socket 等待队列删除</p></li> <li><p>当 socket 收到数据后, 中断程序会操作 eventpoll 对象, 而不是直接操作进程</p> <ul><li>所有添加到 epoll 的事件都会与设备网卡驱动程序建立回调关系, 当相应的事件发生时会调用这个
回调方法. 这个回调方法在内核中叫 <code>ep_poll_callback</code>, 会将发生的事件添加到 rdlist 链
表中</li> <li>epoll 中, 对于每个事件, 都会建立一个 epitem 结构体</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">epitem</span><span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rbn<span class="token punctuation">;</span>  <span class="token comment">//红黑树节点</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllink<span class="token punctuation">;</span> <span class="token comment">//双向链表节点</span>
  <span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> ffd<span class="token punctuation">;</span>  <span class="token comment">//事件句柄信息</span>
  <span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>     <span class="token comment">//指向其所属的 eventpoll 对象</span>
  <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> event<span class="token punctuation">;</span> <span class="token comment">//期待发生的事件类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>添加要监听的 socket</strong><br><img src="/image/network/socket-api/001_epoll_add_rdlist.webp" alt="添加要监听的 socket"></p></li></ul> <h3 id="接收数据"><a href="#接收数据" class="header-anchor">#</a> 接收数据</h3> <ul><li><p>socket 接收到数据后, 中断程序会给 eventpoll 的 rdlist 添加 socket 引用</p></li> <li><p>eventpoll 对象相当与 socket 和进程之间的中介, socket 的数据接收并不直接影响进程, 而是通
过改变 eventpoll 的 rdlist 来改变进程状态</p></li> <li><p>当程序执行 <code>epoll_wait()</code> 时, 如果 rdlist 已经引用了 socket, 那么 <code>epoll_wait()</code>
直接返回, 如果 rdlist 为空则进程阻塞</p> <ul><li>调用 <code>epoll_wait()</code> 检查是否有事件发生时, 只需要检查 eventpoll.rdlist 双链表中是否
有 epitem 元素即可. 如果 rdlist 不为空, 则把发生的事件复制到用户态, 同时将事件数量返回
给用户</li></ul> <p><strong>给 rdlist 添加引用</strong><br><img src="/image/network/socket-api/001_epoll_rdlist_add_reference.webp" alt="给 rdlist 添加引用"></p></li></ul> <h3 id="阻塞和唤醒进程"><a href="#阻塞和唤醒进程" class="header-anchor">#</a> 阻塞和唤醒进程</h3> <ul><li><p>程序运行到 <code>epoll_wait()</code> 时, 进程阻塞. 此时内核会将进程放入到 eventpoll 的等待队列</p></li> <li><p>socket 接收到数据后, 中断程序一方面修改 rdlist, 另一方面唤醒 eventpoll 等待队列中的进程,
进程再次进入运行态. 进程根据 rdlist 可以知道哪些 socket 发生了变化</p> <p><strong>epoll_wait 阻塞进程</strong><br><img src="/image/network/socket-api/001_epoll_epoll_wait.webp" alt="epoll_wait 阻塞进程"></p> <p><strong>epoll 唤醒进程</strong><br><img src="/image/network/socket-api/001_epoll_wakeup_process.webp" alt="epoll 唤醒进程"></p></li></ul> <h2 id="epoll-实现细节"><a href="#epoll-实现细节" class="header-anchor">#</a> epoll 实现细节</h2> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">{</span>
  wait_queue_head_t wq<span class="token punctuation">;</span>
  wait_queue_head_t poll_wait<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>ovflist<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>    <span class="token comment">// fd对应的文件表入口</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token punctuation">{</span>
  <span class="token keyword">union</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rbn<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllink<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> ffd<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> pwqlist<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> fllink<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> event<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ul><li><p>rdlist</p> <ul><li>双向链表, 快速插入和删除</li> <li>rdlist 通过 epitem 间接引用 socket</li></ul></li> <li><p>索引结构</p> <ul><li>红黑树, 快速添加, 删除, 搜索</li> <li>保存监视的 socket</li></ul> <p><strong>epoll 原理</strong><br><img src="/image/network/socket-api/001_epoll_datastructure.webp" alt="epoll 原理"></p></li></ul> <p><em><strong>Q. 为什么能支持百万句柄如此高效?</strong></em></p> <ul><li><strong>不用重复传递</strong>, 调用 <code>epoll_wait()</code> 就相当于调用 <code>selelct/poll</code>, 但此时不用传递
socket 句柄给内核, 因为内核已经在 <code>epoll_ctl()</code> 中拿到了要监控的句柄列表</li> <li>内核中, 一切皆文件. epoll 向内核注册了一个文件系统, 用于存储被监控的 socket. 当调用
<code>epoll_create()</code> 时, 就会在这个虚拟的 epoll 文件系统中创建一个 file 节点, 这个节点
不时普通的文件, 只服务于 epoll. epoll 在被内核初始化时, 同时会开辟出 epoll 自己的内核
高速 cache, 用于存放每一个想要监控的 socket, 这些 socket 会以红黑树的形式保存在内存
cache 中, 以支持快速的查抄, 删除, 插入. 所以在内存上分配好想要的 size 的内存对象, 每次
使用时都是使用空闲的已分配好的对象</li> <li>高效原因. 内核除了在 epoll 文件系统中创建 file 节点, 在内核 cache 中建立红黑树以存储后
续 <code>epoll_ctl()</code> 传来的 socket 外, 还会再建一个 list 链表, 用于存储准备就绪的事件,
<code>epoll_wait()</code> 时, 仅仅观察这个 list 链表里有没有数据即可. 有数据就返回, 没有数据就
sleep, 等到 timeout 时间到后即使链表没有数据也返回.
<ul><li>rdlist 维护. <strong>epoll 的基础就是回调</strong>. 执行 <code>epoll_ctl()</code> 时, 除了把 socket 放到
epoll 文件系统里 file 对象对应的红黑树上, 还会给内核中断处理程序注册一个回调函数, 使得
内核在这个句柄中断到了时, 将它放到准备就绪 rdlist 里. 所以当一个 socket 上有数据时,
内核把网卡上的数据 copy 到内核中后, 就会将 socket 插入到 rdlist 中.</li></ul></li> <li>总结下流程
<ol><li><code>epoll_create()</code> 创建红黑树和 rdlist</li> <li><code>epoll_ctl()</code> 增加 socket 句柄时, 检查红黑树中是否存在, 存在就立即返回, 不存在则添加
到树干上; 然后向内核注册回调函数, 用于当中断事件来临时向 rdlist 中插入数据</li> <li><code>epoll_wait()</code> 立刻返回 rdlist 中的数据</li></ol></li></ul> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <p><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener noreferrer">如果这篇文章说不清 epoll 的本质, 那就过来掐死我吧!<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br> <a href="https://www.cnblogs.com/charlesblc/p/6242479.html" target="_blank" rel="noopener noreferrer">epoll的内部实现 &amp; 百万级别句柄监听 &amp; lt和et模式非常好的解释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/louistin/blog.liteman/edit/master/docs/network/socket-api/epoll 详解.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">2020-05-25 21:12:08 UTC+08:00</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/network/tcp-ip/DNS 协议.html" class="prev">
        DNS 协议
      </a></span> <!----></p></div> </main></div><div class="global-ui"><div class="reading-progress top" data-v-21b39eda><div class="progress" data-v-21b39eda></div></div><!----></div></div>
    <script src="/assets/js/app.5aa78949.js" defer></script><script src="/assets/js/2.db8a1bd9.js" defer></script><script src="/assets/js/27.d86ae0b6.js" defer></script>
  </body>
</html>
