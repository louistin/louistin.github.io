(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{341:function(t,e,_){"use strict";_.r(e);var a=_(8),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"reactor-反应堆模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reactor-反应堆模式"}},[t._v("#")]),t._v(" Reactor 反应堆模式")]),t._v(" "),_("blockquote",[_("p",[t._v("Reactor 用于同步 I/O")])]),t._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#前置概念"}},[t._v("前置概念")]),_("ul",[_("li",[_("a",{attrs:{href:"#阻塞与非阻塞"}},[t._v("阻塞与非阻塞")])]),_("li",[_("a",{attrs:{href:"#同步与异步"}},[t._v("同步与异步")])]),_("li",[_("a",{attrs:{href:"#i-o-模型"}},[t._v("I/O 模型")])]),_("li",[_("a",{attrs:{href:"#网络请求处理结构"}},[t._v("网络请求处理结构")])])])]),_("li",[_("a",{attrs:{href:"#reactor-模式"}},[t._v("Reactor 模式")]),_("ul",[_("li",[_("a",{attrs:{href:"#reactor-模式框架"}},[t._v("Reactor 模式框架")])])])])])]),_("p"),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"前置概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前置概念"}},[t._v("#")]),t._v(" 前置概念")]),t._v(" "),_("h3",{attrs:{id:"阻塞与非阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阻塞与非阻塞"}},[t._v("#")]),t._v(" 阻塞与非阻塞")]),t._v(" "),_("p",[t._v("描述的是用户线程调用系统内核 I/O 操作的方式")]),t._v(" "),_("ul",[_("li",[t._v("阻塞\n"),_("ul",[_("li",[t._v("I/O 操作需要彻底完成后才返回到用户空间")])])]),t._v(" "),_("li",[t._v("非阻塞\n"),_("ul",[_("li",[t._v("I/O 操作被调用后立即返回给用户一个状态值, 无需等到 I/O 操作彻底完成")])])])]),t._v(" "),_("h3",{attrs:{id:"同步与异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步与异步"}},[t._v("#")]),t._v(" 同步与异步")]),t._v(" "),_("p",[t._v("描述的是用户线程与内核的交互方式")]),t._v(" "),_("ul",[_("li",[t._v("同步\n"),_("ul",[_("li",[t._v("用户线程发起 I/O 请求后需要等待或轮询内核 I/O 操作完成后才能继续执行")])])]),t._v(" "),_("li",[t._v("异步\n"),_("ul",[_("li",[t._v("用户线程发起 I/O 请求后仍继续执行, 当内核 I/O 操作完成后会通知用户线程, 或者调用用户线程\n注册的回调函数")])])])]),t._v(" "),_("h3",{attrs:{id:"i-o-模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#i-o-模型"}},[t._v("#")]),t._v(" I/O 模型")]),t._v(" "),_("h4",{attrs:{id:"同步阻塞-i-o-blocking-i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步阻塞-i-o-blocking-i-o"}},[t._v("#")]),t._v(" 同步阻塞 I/O Blocking I/O")]),t._v(" "),_("p",[t._v("传统 I/O 模型, 用户线程在内核进行 I/O 操作时被阻塞.")]),t._v(" "),_("p",[_("strong",[t._v("同步阻塞 I/O")]),_("br"),_("img",{attrs:{src:t.$withBase("/image/cs/design-pattern/001_reactor_blocking_io.webp"),alt:"同步阻塞 I/O"}})]),t._v(" "),_("h4",{attrs:{id:"同步非阻塞-i-o-non-blocking-i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步非阻塞-i-o-non-blocking-i-o"}},[t._v("#")]),t._v(" 同步非阻塞 I/O Non-Blocking I/O")]),t._v(" "),_("p",[t._v("默认创建的 socket 都是阻塞的, 非阻塞要求 socket 设置为 NONBLOCK.")]),t._v(" "),_("p",[_("strong",[t._v("同步非阻塞 I/O")]),_("br"),_("img",{attrs:{src:t.$withBase("/image/cs/design-pattern/001_reactor_nonblocking_io.webp"),alt:"同步非阻塞 I/O"}})]),t._v(" "),_("h4",{attrs:{id:"i-o-多路复用-i-o-multiplexing"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#i-o-多路复用-i-o-multiplexing"}},[t._v("#")]),t._v(" I/O 多路复用 I/O Multiplexing")]),t._v(" "),_("p",[t._v("也称异步阻塞 I/O. Reactor 设计模式.")]),t._v(" "),_("p",[t._v("I/O 多路复用模型是建立在内核提供的多路复用分离函数基础之上的.")]),t._v(" "),_("ul",[_("li",[t._v("使用 select 函数可以避免同步非阻塞模型中的轮询等待问题")])]),t._v(" "),_("p",[_("strong",[t._v("多路分离函数 select")]),_("br"),_("img",{attrs:{src:t.$withBase("/image/cs/design-pattern/001_reactor_io_multiplexing_select.webp"),alt:"多路分离函数 select"}})]),t._v(" "),_("h4",{attrs:{id:"异步-io-asynchronous-i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步-io-asynchronous-i-o"}},[t._v("#")]),t._v(" 异步 IO Asynchronous I/O")]),t._v(" "),_("p",[t._v("也称异步非阻塞 I/O. Proactor")]),t._v(" "),_("h3",{attrs:{id:"网络请求处理结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络请求处理结构"}},[t._v("#")]),t._v(" 网络请求处理结构")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("基于线程")])]),t._v(" "),_("li",[_("p",[t._v("事件驱动")]),t._v(" "),_("ul",[_("li",[t._v("事件驱动程序的基本结构\n"),_("ul",[_("li",[t._v("事件收集器, 负责收集所有事件, 包括来自用户, 硬件和软件的事件")]),t._v(" "),_("li",[t._v("事件发送器, 将收集到的事件分发到目标对象中")]),t._v(" "),_("li",[t._v("事件处理器, 执行具体的事件响应工作, 一般在实现阶段才完全确定")])])]),t._v(" "),_("li",[t._v("事件驱动编程使用协作式处理任务, 而不是多线程抢占式, 处理器一般只有很短的生命周期")]),t._v(" "),_("li",[t._v("优点:\n"),_("ul",[_("li",[t._v("编程简单, 复杂度低")]),t._v(" "),_("li",[t._v("事件驱动编程可以很好的实现 I/O 复用")]),t._v(" "),_("li",[t._v("易于调试, 时间依赖只和事件有关, 而不是内部调度")])])]),t._v(" "),_("li",[t._v("缺点:\n"),_("ul",[_("li",[t._v("如果处理器占用时间较长, 会阻塞应用程序的响应")]),t._v(" "),_("li",[t._v("无法通过时间来维护本地状态, 处理器必须返回")]),t._v(" "),_("li",[t._v("在单 CPU 环境下, 比多线程要快, 因为没有锁的因素, 没有线程切换的损耗, CPU 不是并发")])])])])])]),t._v(" "),_("h2",{attrs:{id:"reactor-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reactor-模式"}},[t._v("#")]),t._v(" Reactor 模式")]),t._v(" "),_("p",[t._v("Reactor 模式常用于处理并发 I/O, 用于同步 I/O. 主要设计思想是将所有要处理的 I/O 事件注册到\n一个中心 I/O 多路复用器上, 同时主线程阻塞在多路复用器上, 一旦有 I/O 事件到来或准备就绪, 多路\n复用器将返回并将相应的 I/O 事件分发到对应得处理器中.")]),t._v(" "),_("p",[t._v("Reactor 是一种事件驱动机制, 应用程序不会主动调用 API 来完成处理. Reactor 逆置了事件处理流\n程, 应用程序需要提供相应得接口并注册到 Reactor 上, 如果有相应得事件发生, Reactor 将主动调用\n应用程序注册得 API (回调函数).")]),t._v(" "),_("ul",[_("li",[t._v("优点:\n"),_("ul",[_("li",[t._v("响应快, 不必为单个同步时间所阻塞, 虽然 Reactor 本身依然是同步的")]),t._v(" "),_("li",[t._v("变成相对简单, 可以最大程度的避免复杂的多线程及同步问题, 并且避免了多线程/进程的切换开销")]),t._v(" "),_("li",[t._v("可扩展性, 可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源")]),t._v(" "),_("li",[t._v("可复用性, Reactor 框架本身与具体时间处理逻辑无关, 具有很高的复用性")])])])]),t._v(" "),_("h3",{attrs:{id:"reactor-模式框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reactor-模式框架"}},[t._v("#")]),t._v(" Reactor 模式框架")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("事件源 Handle")]),t._v(" "),_("ul",[_("li",[t._v("Linux 上为文件描述符, 称为句柄集 Handle, 程序在指定的句柄上注册关心的事件, 如 I/O 事件")])])]),t._v(" "),_("li",[_("p",[t._v("事件多路分发机制 EventDemultiplexer")]),t._v(" "),_("ul",[_("li",[t._v('由操作系统提供的 I/O 多路复用机制, select epoll 等. 程序首先将关心的句柄(事件源) 及其\n事件注册到多路复用机制上; 当有事件到达时, 事件多路复用机制会发出通知"在已注册的句柄集中,\n有一个或多个句柄的事件已就绪", 程序收到通知后, 就可以在非阻塞的情况下对事件进行处理了.')]),t._v(" "),_("li",[t._v("事件分离器由操作系统提供, select epoll 等, 在一个 Handle 集合上等待事件的发生. 接收\nclient 连接, 建立对应 client 的事件处理器 EventHandler, 并向事件分发器 Reactor 注\n册此事件处理器")])])]),t._v(" "),_("li",[_("p",[t._v("反应器 Reactor")]),t._v(" "),_("ul",[_("li",[t._v("事件管理的接口, 内部使用事件多路复用机制注册, 注销事件; 并运行事件循环, 当有事件进入就绪\n状态时, 调用注册事件的回调函数处理事件")]),t._v(" "),_("li",[t._v("提供接口注册, 删除和分发 EventHandler, EventDemultiplexer 等待事件发生, 当检测到\n新的事件, 就把事件交给 dispatcher, 由其回调 EventHandler")])])]),t._v(" "),_("li",[_("p",[t._v("事件处理程序 Eventhandler")]),t._v(" "),_("ul",[_("li",[t._v("事件处理程序提供了一组接口, 每个接口对应了一种类型的事件, 供 Reactor 在相应的事件发生时\n调用, 执行相应的事件处理, 通常它会绑定一个有效的句柄.")]),t._v(" "),_("li",[t._v("事件处理器, 负责处理特定事件的处理函数, 一般基本的 Handler 基础上还会有更进一步的层次划\n分, 用来抽象诸如 decode, process, encode 等过程.")])])]),t._v(" "),_("li",[_("p",[t._v("具体的事件处理器 ConcreteEventHandler")]),t._v(" "),_("p",[_("strong",[t._v("Reactor 设计模式")]),_("br"),_("img",{attrs:{src:t.$withBase("/image/cs/design-pattern/001_reactor_001.webp"),alt:"Reactor 设计模式"}})])])]),t._v(" "),_("h4",{attrs:{id:"使用同步-i-o-模型-epoll-实现的-reactor-模式工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用同步-i-o-模型-epoll-实现的-reactor-模式工作流程"}},[t._v("#")]),t._v(" 使用同步 I/O 模型 epoll 实现的 Reactor 模式工作流程")]),t._v(" "),_("ol",[_("li",[_("code",[t._v("epoll_create()")])]),t._v(" "),_("li",[_("code",[t._v("epoll_ctl(epfd, EPOLL_CTL_ADD, fd, event)")]),t._v(" 主线程向 epoll 内核事件表中注册\nsocket 上的 EPOLLIN 事件")]),t._v(" "),_("li",[t._v("当 socket 上有数据可读时, "),_("code",[t._v("epoll_wait()")]),t._v(" 通知主线程, 主线程将 socket 可读事件放入\n请求队列")]),t._v(" "),_("li",[t._v("休眠在请求队列上的某个工作线程被唤醒, 从 socket 中读取数据并处理客户端请求, 然后向 epoll\n内核事件表中注册该 socket 上的写就绪事件")]),t._v(" "),_("li",[t._v("主线程调用 "),_("code",[t._v("epoll_wait()")]),t._v(" 等待 socket 可写")]),t._v(" "),_("li",[t._v("当 socket 可写时 "),_("code",[t._v("epoll_wait()")]),t._v(" 通知主线程, 主线程将 socket 可写事件放入请求队列")]),t._v(" "),_("li",[t._v("休眠在请求队列上的某个工作线程被唤醒, 向 socket 上写入服务器处理请求的结果")])]),t._v(" "),_("p",[_("strong",[t._v("epoll 流程")]),_("br"),_("img",{attrs:{src:t.$withBase("/image/cs/design-pattern/001_reactor_epoll_001.webp"),alt:"epoll 流程"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);