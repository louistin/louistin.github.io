<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构与算法 | 🔞の領域</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/image/favicon.png">
    <meta name="description" content="　我们立足于美利坚合众国, 针对年满18周岁非大陆全球华人开发, 受北美法律保护.　 　　　　　　　　　　　　　未經授權禁止复制或建立镜像. 　　　　　　　　　　　　We are based in the United States of America, for over 18 years of age non-mainland Chinese open world, by the North American legal protection. Unauthorized reproduction prohibited or create mirror.">
    <link rel="preload" href="/assets/css/0.styles.eda1073d.css" as="style"><link rel="preload" href="/assets/js/app.5aa78949.js" as="script"><link rel="preload" href="/assets/js/2.db8a1bd9.js" as="script"><link rel="preload" href="/assets/js/11.7fc433a5.js" as="script"><link rel="prefetch" href="/assets/js/10.cb22b5cc.js"><link rel="prefetch" href="/assets/js/12.26e9cadb.js"><link rel="prefetch" href="/assets/js/13.1258d0f5.js"><link rel="prefetch" href="/assets/js/14.99ec5e93.js"><link rel="prefetch" href="/assets/js/15.5e075e9b.js"><link rel="prefetch" href="/assets/js/16.3ae89ebf.js"><link rel="prefetch" href="/assets/js/17.a0578cc8.js"><link rel="prefetch" href="/assets/js/18.57573e35.js"><link rel="prefetch" href="/assets/js/19.1921cef9.js"><link rel="prefetch" href="/assets/js/20.21e6a458.js"><link rel="prefetch" href="/assets/js/21.85d787bf.js"><link rel="prefetch" href="/assets/js/22.463f771e.js"><link rel="prefetch" href="/assets/js/23.a24c9494.js"><link rel="prefetch" href="/assets/js/24.4e9dffaf.js"><link rel="prefetch" href="/assets/js/25.48966cca.js"><link rel="prefetch" href="/assets/js/26.79a3a1f7.js"><link rel="prefetch" href="/assets/js/27.d86ae0b6.js"><link rel="prefetch" href="/assets/js/28.3085660e.js"><link rel="prefetch" href="/assets/js/29.b25e9aa3.js"><link rel="prefetch" href="/assets/js/3.bfe9edf0.js"><link rel="prefetch" href="/assets/js/30.32eb4625.js"><link rel="prefetch" href="/assets/js/31.c255a7cd.js"><link rel="prefetch" href="/assets/js/32.d4a5e1b3.js"><link rel="prefetch" href="/assets/js/33.939416f6.js"><link rel="prefetch" href="/assets/js/34.1527656e.js"><link rel="prefetch" href="/assets/js/35.31254244.js"><link rel="prefetch" href="/assets/js/36.4c9eea64.js"><link rel="prefetch" href="/assets/js/37.dcba8e22.js"><link rel="prefetch" href="/assets/js/38.660f4f18.js"><link rel="prefetch" href="/assets/js/39.36808ac4.js"><link rel="prefetch" href="/assets/js/4.721e6361.js"><link rel="prefetch" href="/assets/js/40.5e3d825d.js"><link rel="prefetch" href="/assets/js/41.8bc35558.js"><link rel="prefetch" href="/assets/js/42.3d9ee979.js"><link rel="prefetch" href="/assets/js/43.d8a9355a.js"><link rel="prefetch" href="/assets/js/44.3b96fdab.js"><link rel="prefetch" href="/assets/js/45.5a397a89.js"><link rel="prefetch" href="/assets/js/46.2c015a12.js"><link rel="prefetch" href="/assets/js/47.cb620ad3.js"><link rel="prefetch" href="/assets/js/48.63e77fd7.js"><link rel="prefetch" href="/assets/js/49.3a1743f4.js"><link rel="prefetch" href="/assets/js/5.9c8aa7de.js"><link rel="prefetch" href="/assets/js/50.858e22ae.js"><link rel="prefetch" href="/assets/js/51.d5ea8da3.js"><link rel="prefetch" href="/assets/js/6.cfcb9227.js"><link rel="prefetch" href="/assets/js/7.7ef2cd09.js"><link rel="prefetch" href="/assets/js/8.8cae79fc.js"><link rel="prefetch" href="/assets/js/9.116ce45e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.eda1073d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">🔞の領域</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/cs/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络编程
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  后端开发
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  前端开发
</a></div><div class="nav-item"><a href="/opensource/" class="nav-link">
  开源软件
</a></div><div class="nav-item"><a href="/note/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/manual/" class="nav-link">
  开发手册
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/louistin/blog.liteman.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/cs/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络编程
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  后端开发
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  前端开发
</a></div><div class="nav-item"><a href="/opensource/" class="nav-link">
  开源软件
</a></div><div class="nav-item"><a href="/note/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/manual/" class="nav-link">
  开发手册
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/louistin/blog.liteman.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据结构与算法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cs/dsa/数据结构与算法.html" class="active sidebar-link">数据结构与算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_01-算法简介" class="sidebar-link">01 - 算法简介</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_02-算法" class="sidebar-link">02 - 算法</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_03-线性表-list" class="sidebar-link">03 - 线性表 List</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_04-栈与队列" class="sidebar-link">04 - 栈与队列</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_05-串-string" class="sidebar-link">05 - 串 String</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_06-树-tree" class="sidebar-link">06 - 树 Tree</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_07-图-graph" class="sidebar-link">07 - 图 Graph</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_08-查找" class="sidebar-link">08 - 查找</a></li><li class="sidebar-sub-header"><a href="/cs/dsa/数据结构与算法.html#_09-排序" class="sidebar-link">09 - 排序</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="header-anchor">#</a> 数据结构与算法</h1> <blockquote><p align="left" style="font-family:Arial;font-size:80%;color:#C0C0C0;">全文字数 2282 words  |  阅读时间 12 mins</p>
以大话数据结构为参考书籍对数据结构与算法做一个较全面的认知(其实本书看着真烦🤯
</blockquote> <hr> <p></p><div class="table-of-contents"><ul><li><a href="#_01-算法简介">01 - 算法简介</a></li><li><a href="#_02-算法">02 - 算法</a></li><li><a href="#_03-线性表-list">03 - 线性表 List</a></li><li><a href="#_04-栈与队列">04 - 栈与队列</a></li><li><a href="#_05-串-string">05 - 串 String</a></li><li><a href="#_06-树-tree">06 - 树 Tree</a></li><li><a href="#_07-图-graph">07 - 图 Graph</a></li><li><a href="#_08-查找">08 - 查找</a></li><li><a href="#_09-排序">09 - 排序</a></li></ul></div><p></p> <h2 id="_01-算法简介"><a href="#_01-算法简介" class="header-anchor">#</a> 01 - 算法简介</h2> <blockquote><p>数据结构: 相互之间存在一种或多种特定关系的数据元素的集合</p></blockquote> <ul><li><p>逻辑结构与物理结构</p> <ul><li>逻辑结构
<ul><li>集合结构</li> <li>线性结构</li> <li>树形结构</li> <li>图形结构</li></ul></li> <li>物理结构
<ul><li>顺序存储结构</li> <li>链式存储结构</li></ul></li></ul></li> <li><p>抽象数据类型 ADT</p> <ul><li>一个数学模型及定义在该模型上的一组操作</li> <li>抽象数据类型体现了程序设计中问题分解, 抽象和信息隐藏的特性</li></ul></li></ul> <h2 id="_02-算法"><a href="#_02-算法" class="header-anchor">#</a> 02 - 算法</h2> <blockquote><p>算法是解决特定问题求解步骤的描述, 在计算机中表现为指令的有限序列, 并且每条指令表示一个或多个
操作.</p></blockquote> <ul><li>算法特性
<ul><li>输入</li> <li>输出</li> <li>有穷性</li> <li>确定性</li> <li>可行性</li></ul></li> <li>算法设计要求
<ul><li>正确性</li> <li>可读性</li> <li>健壮性</li> <li>时间效率高和存储量低</li></ul></li> <li>算法时间复杂度
<ul><li><code>O()</code> <ul><li><code>O(1)</code> 常数阶</li> <li><code>O(logn)</code> 对数阶</li> <li><code>O(n)</code> 线性阶</li> <li><code>O(nlogn)</code> nlogn阶</li> <li><code>O(n^2)</code> 平方阶</li> <li><code>O(n^3)</code> 立方阶</li> <li><code>O(2^n)</code> 指数阶</li></ul></li> <li>算法空间复杂度</li></ul></li></ul> <h2 id="_03-线性表-list"><a href="#_03-线性表-list" class="header-anchor">#</a> 03 - 线性表 List</h2> <blockquote><p>零个或多个数据元素的有限序列</p></blockquote> <ul><li>线性表
<ul><li>元素有顺序的序列, 第一个元素无前驱, 最后一个元素无后继, 其他每个元素有且只有一个前驱和后继</li> <li>元素个数有限</li> <li>每个数据元素可以由若干个数据项组成</li></ul></li> <li>线性表的顺序存储结构
<ul><li>可以使用一维数组实现顺序存储结构</li> <li>优点
<ul><li>无需为表中元素之间的逻辑关系而增加额外的空间</li> <li>可以快速存取表中任一位置的元素</li></ul></li> <li>缺点
<ul><li>插入和删除需要移动大量元素</li> <li>线性表长度较大时, 难以确定存储空间和容量</li> <li>造成存储空间碎片</li></ul></li></ul></li> <li>线性表的链式存储结构
<ul><li><p>单链表</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>      <span class="token comment">// 数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 指针域</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>循环链表
<ul><li>将单链表终端节点的指针域由空指针改为指向头结点</li></ul></li></ul></li> <li><p>双向链表</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DulNode</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">DulNode</span> <span class="token operator">*</span>prior<span class="token punctuation">;</span>  <span class="token comment">// 直接前驱指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">DulNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>   <span class="token comment">// 直接后继指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DulNode</span> <span class="token operator">*</span>DuLinkList<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>双向循环链表</li></ul></li></ul></li></ul> <h2 id="_04-栈与队列"><a href="#_04-栈与队列" class="header-anchor">#</a> 04 - 栈与队列</h2> <blockquote><p>栈: 仅在表尾进行插入和删除操作的线性表, 先进后出<br>
队列: 只允许在一端进行插入操作, 在另一端进行删除操作的线性表, 先进先出</p></blockquote> <ul><li><p>栈</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 栈的顺序存储结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> SElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SqStack</span> <span class="token punctuation">{</span>
    SElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>          <span class="token comment">// 用于栈顶指针, -1 空栈</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 链栈</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackNode</span> <span class="token punctuation">{</span>
    SElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">StackNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> StackNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkStackPtr<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkStack</span> <span class="token punctuation">{</span>
    LinkStackPtr top<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span> LinkStack<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li> <li><p>递归</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">fbi</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">fbi</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fbi</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;第 %d 月, 兔子数量为: %d.\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">fbi</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li> <li><p>栈的应用: 四则预案算表达式求值</p> <ul><li><p>后缀表达式</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token number">9</span> + <span class="token punctuation">(</span><span class="token number">3</span> - <span class="token number">1</span><span class="token punctuation">)</span> * <span class="token number">3</span> + <span class="token number">10</span> / <span class="token number">2</span>    <span class="token comment"># 中缀表达式</span>
<span class="token number">9</span> <span class="token number">3</span> <span class="token number">1</span> - <span class="token number">3</span> * + <span class="token number">10</span> <span class="token number">2</span> / +      <span class="token comment"># 后缀表达式</span>

将中缀表达式转化为后缀表达式<span class="token punctuation">(</span>栈用来进出运算符号<span class="token punctuation">)</span>
将后缀表达式进行运算得出结果<span class="token punctuation">(</span>栈用来进出运算数字<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul></li> <li><p>队列</p> <ul><li>头出尾插</li></ul></li> <li><p>循环队列</p> <ul><li><p>头尾相接的顺序存储结构</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># rear 后保留一个空单元, 即认为已满</span>
<span class="token number">0</span>    <span class="token number">1</span>    <span class="token number">2</span>    <span class="token number">3</span>    <span class="token number">4</span> 空         <span class="token number">0</span>    <span class="token number">1</span>    <span class="token number">2</span> 空 <span class="token number">3</span>    <span class="token number">4</span>
front                rear                  rear front

队列满的条件: <span class="token punctuation">(</span>rear + <span class="token number">1</span><span class="token punctuation">)</span> % QueueSize <span class="token operator">==</span> front
队列长度计算: <span class="token punctuation">(</span>rear - front + QueueSize<span class="token punctuation">)</span> % QueueSize
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul></li> <li><p>队列的链式存储结构</p></li></ul> <h2 id="_05-串-string"><a href="#_05-串-string" class="header-anchor">#</a> 05 - 串 String</h2> <blockquote><p>由零个或多个字符组成的有限序列</p></blockquote> <ul><li>串的存储结构
<ul><li>顺序存储(更好)</li> <li>链式存储</li></ul></li> <li>模式匹配算法
<ul><li>效率太低</li></ul></li> <li>KMP 模式匹配算法</li></ul> <h2 id="_06-树-tree"><a href="#_06-树-tree" class="header-anchor">#</a> 06 - 树 Tree</h2> <blockquote><p>树是 n(n &gt;= 0) 个结点的有限集. n = 0 时称为空树.<br>
在任何一个非空树中:<br></p> <ol><li>有且只有一个特定的称为根 Root 的结点<br></li> <li>当 n &gt; 1 时, 其余结点可分为 m (m &gt; 0) 个互不相交的有限集 T1, T2, ... Tm, 其中每个
集合本身又是一棵树, 并且称为根的子树 SubTree</li></ol></blockquote> <ul><li><p>树</p> <ul><li>结点拥有的子树树称为结点的度 Degree
<ul><li>度为 0 的结点称为叶节点 Leaf</li> <li>度不为 0 的结点称为分支结点</li></ul></li> <li>树的度是树内各结点的度的最大值</li></ul></li> <li><p>树的存储结构</p> <ul><li><p>双亲表示法</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> MAX_TREE_SIZE   100</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> TElemType

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    TElemType data<span class="token punctuation">;</span>   <span class="token comment">// 结点数据</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>       <span class="token comment">// parent 位置(数组下标)</span>
<span class="token punctuation">}</span> PTNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> r<span class="token punctuation">;</span>      <span class="token comment">// 根的位置, 根结点为 -1</span>
  <span class="token keyword">int</span> n<span class="token punctuation">;</span>      <span class="token comment">// 结点数</span>
<span class="token punctuation">}</span> PTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li> <li><p>孩子表示法</p> <ul><li>多重链表表示法
<ul><li>每个结点有多个指针域, 每个指针指向一棵子树的根结点</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> MAX_TREE_SIZE   100</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> TElemType

<span class="token comment">// 孩子结点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> child<span class="token punctuation">;</span>      <span class="token comment">// 存储某个结点在表头数组中的下标</span>
  <span class="token keyword">struct</span> <span class="token class-name">CTNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 指向某结点的下一个孩子结点</span>
<span class="token punctuation">}</span> <span class="token operator">*</span>ChildPtr<span class="token punctuation">;</span>

<span class="token comment">// 表头结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  TElemType data<span class="token punctuation">;</span>       <span class="token comment">// 结点数据</span>
  ChildPtr firstchild<span class="token punctuation">;</span>  <span class="token comment">// 指向结点的孩子链表</span>
<span class="token punctuation">}</span> CTBox<span class="token punctuation">;</span>

<span class="token comment">// 树结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  CTBox nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> r<span class="token punctuation">;</span>
  <span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li> <li><p>孩子兄弟表示法</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token punctuation">{</span>
  TElemType data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>firstchild<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>rightchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul></li> <li><p>二叉树</p> <ul><li>斜树</li> <li>满二叉树</li> <li>完全二叉树</li></ul></li> <li><p>二叉树的存储结构</p> <ul><li><p>顺序存储结构</p> <ul><li>适用于完全二叉树</li></ul></li> <li><p>二叉链表</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token punctuation">{</span>
    TElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    <span class="token comment">// 左右孩子指针</span>
<span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul></li> <li><p>二叉树的遍历</p> <ul><li><p>前序遍历</p> <ul><li>若二叉树为空, 则空操作返回, 否则先访问根结点, 然后前序遍历左子树, 再前序遍历右子树</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span> T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>中序遍历</p> <ul><li>若树为空, 则空操作返回, 否则从根结点开始(不是首先访问根结点), 中序遍历根结点的左子树,
然后访问根结点, 最后中序遍历右子树</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span> T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>后序遍历</p> <ul><li>若树为空, 则空操作返回, 否则从左到右先叶子后结点的方式访问左右子树, 最后访问根结点</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span> T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>层序遍历</p> <ul><li>若树为空, 则空操作返回, 否则从树的第一层, 也就是根结点开始访问, 从上而下逐层遍历, 在同
一层, 按从左到右的顺序对结点逐个访问</li></ul></li></ul></li> <li><p>二叉树的建立</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 按照前序方式输入二叉树结点的值, 每个结点值为一个字符</span>
<span class="token comment">// # 表示空树, 需要将原二叉树填充 # 扩展为完全二叉树(每个结点的空指针都引出一个虚结点)</span>
<span class="token comment">// 如 AB#D##C##</span>
<span class="token keyword">void</span> <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TElemType ch<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%c&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'#'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>    <span class="token comment">// 生成根结点</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构造左子树</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构造右子树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li> <li><p>线索二叉树</p> <ul><li><p>线索化的实质是将二叉链表中的空指针改为指向前驱或后继的线索. 线索化的过程就是在遍历的过程
中修改空指针的过程.</p></li> <li><p>线索二叉树的操作实际上就是操作一个双向链表结构</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// Link == 0 表示指向左右孩子指针</span>
<span class="token comment">// Thread == 0 表示指向前驱或后继的线索</span>
<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>Link<span class="token punctuation">,</span> Thread<span class="token punctuation">}</span> PointerTag<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span> <span class="token punctuation">{</span>
    TElemType data<span class="token punctuation">;</span>             <span class="token comment">// 结点数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">// 左右孩子指针</span>
    PointerTag LTag<span class="token punctuation">;</span>
    PointerTag RTag<span class="token punctuation">;</span>    <span class="token comment">// 左右标志</span>
<span class="token punctuation">}</span> BiThrNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span>

<span class="token comment">// 全局变量, 指向刚刚访问过的结点</span>
BiThrTree pre<span class="token punctuation">;</span>
<span class="token comment">// 中序遍历进行中序线索化</span>
<span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiThrTree p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p<span class="token operator">-&gt;</span>LTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>   <span class="token comment">// 前驱线索</span>
            p<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> pre<span class="token punctuation">;</span>    <span class="token comment">// 左孩子指针指向前驱</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pre<span class="token operator">-&gt;</span>RTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span> <span class="token comment">// 后继线索</span>
            pre<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token comment">// 前驱右孩子指针指向后继(当前结点 p)</span>
        <span class="token punctuation">}</span>

        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token comment">// 保持 pre 指向 p 的前驱</span>
        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div></li></ul></li> <li><p>树, 森林与二叉树的转换</p> <ul><li>树转换为二叉树
<ol><li>加线. 所有兄弟结点之间加一条连线</li> <li>去线. 对树中每个结点, 只保留它与第一个孩子结点的连线, 删除它与其他孩子结点之间的连线</li> <li>层次调整. 以树的根结点为轴心, 将整棵树顺时针旋转一定的角度, 使之结构层次分明. 第一个
孩子是二叉树结点的左孩子, 兄弟转换过来的孩子是结点的右孩子</li></ol></li> <li>森林转换为二叉树
<ol><li>把每个树转换为二叉树</li> <li>第一棵二叉树不动, 从第二棵二叉树开始依次把后一棵二叉树的根结点作为前一棵二叉树的根结点
的右孩子, 用线连起来. 当所有二叉树连接起来后就得到了由森林转换来的二叉树</li></ol></li></ul></li> <li><p>赫夫曼树</p> <ul><li>带权路径长度 WPL 最小的二叉树叫做赫夫曼树</li> <li>赫夫曼编码
<ul><li>前缀编码: 要设计长短不等的编码, 必须是任一字符的编码都不是另一个字符的编码的前缀</li></ul></li></ul></li></ul> <h2 id="_07-图-graph"><a href="#_07-图-graph" class="header-anchor">#</a> 07 - 图 Graph</h2> <blockquote><p>图 Graph 是由顶点的有穷非空集合和顶点之间边的集合组成, 通常表示为 G(V, E). 其中 G 表示一
个图, V 是图中顶点的集合, E 是图中边的集合.</p></blockquote> <ul><li><p>图</p> <ul><li>元素称为顶点 Vertex</li> <li>图中任意两个顶点之间都可能有关系, 顶点之间的逻辑关系用边来表示</li> <li>无向边, 无向图
<ul><li>G1 = (V1, {E1})
<ul><li>V1 = {A, B, C, D}</li> <li>E1 = {(A, B), (B, C), (C, D)}</li></ul></li></ul></li> <li>有向边/弧, 有向图
<ul><li>G2 = (V2, {E2})
<ul><li>V2 = {A, B, C, D}</li> <li>E2 = {&lt;A, D&gt;, &lt;B, A&gt;, &lt;C, A&gt;, &lt;B, C&gt;}</li></ul></li></ul></li> <li>简单图
<ul><li>不存在顶点到其自身的边, 且同一条边不重复出现</li></ul></li> <li>无向完全图
<ul><li>无向图中, 任意两个顶点之间都存在边</li></ul></li> <li>有向完全图
<ul><li>有向图中, 任意两个顶点之间都存在方向护卫相反的两条弧</li></ul></li> <li>稀疏图, 稠密图</li> <li>与图的边/弧相关的数叫做权 Weight
<ul><li>带权的图称为网</li></ul></li> <li>子图</li> <li>度 Gegree
<ul><li>无向图中, 和顶点 v 相关联的边的数目, 记为 TD(v)</li> <li>入度 InDegree
<ul><li>以顶点 v 为头的弧的数目, 记为 ID(v)</li></ul></li> <li>出度 OutDegree
<ul><li>以顶点 v 为尾的弧的数目, 记为 OD(v)</li></ul></li> <li>有向图中, 顶点 v 的度 TD(v) = ID(v) + OD(v)</li></ul></li> <li>路径长度: 路径上边或弧的数目</li> <li>环 Cycle: 第一个顶点和最后一个顶点相同的路径</li> <li>连通图 Connected Graph: 图中任意两个顶点都是连通的 (有向图称为强连通图)
<ul><li>无向图中的极大连通子图称为连通分量
<ul><li>要是子图</li> <li>子图要是连通的</li> <li>连通子图含有极大顶点数</li> <li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li></ul></li> <li>有向图中的极大连通子图称为有向图的强连通分量
<ul><li>有向图中, 每一对顶点之间都存在路径(注意路径是有向的), 称为强连通图</li></ul></li></ul></li> <li>连通图的生成树
<ul><li>是一个极小的连通子图, 包含有图中全部的 N 个顶点, 但是只有足以构成一棵树的 N - 1 条边</li> <li>有向树: 一个有向图恰好有一个顶点的入度为 0, 其余顶点的入度为 1</li> <li>一个有向图由若干有向树构成生成森林</li></ul></li></ul></li> <li><p>图的存储结构</p> <ul><li>邻接矩阵 Adjacency Matrix
<ul><li><p>使用两个数组来表示图, 一个一维数组存储图中顶点信息, 一个二维数组存储图中边/弧信息</p> <p><strong>无向图邻接矩阵</strong><br> <img src="/image/cs/dsa/readme/07_graph_adjacency_matrix_001.png" alt="无向图邻接矩阵"></p></li> <li><p>有向网图中, 权值 <code>∞</code> 表示不存在</p> <p><strong>有向网图邻接矩阵</strong><br> <img src="/image/cs/dsa/readme/07_graph_adjacency_matrix_002.png" alt="有向网图邻接矩阵"></p></li> <li><p>邻接矩阵</p> <ul><li><p>边数相对顶点较少时, 存在存储空间浪费</p> <p><strong>邻接矩阵</strong><br> <img src="/image/cs/dsa/readme/07_graph_adjacency_matrix_003.png" alt="邻接矩阵"></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span>        <span class="token comment">// 顶点类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> EdgeType<span class="token punctuation">;</span>           <span class="token comment">// 权值类型</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MAXVEX      100         </span><span class="token comment">// 最大顶点数</span>
<span class="token macro property">#<span class="token directive keyword">define</span> INFINITY    65535       </span><span class="token comment">// 表示无穷大</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    VertexType vexs<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 顶点表</span>
    EdgeType arc<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 邻接矩阵/边表</span>
    <span class="token keyword">int</span> numVertexes<span class="token punctuation">;</span>    <span class="token comment">// 顶点数</span>
    <span class="token keyword">int</span> numEdges<span class="token punctuation">;</span>       <span class="token comment">// 边数</span>
<span class="token punctuation">}</span> MGraph<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul></li> <li><p>邻接表 Adjacency List</p> <ul><li><p>数组与链表相结合的存储方法</p> <p><strong>邻接表</strong><br> <img src="/image/cs/dsa/readme/07_graph_adjacency_matrix_004.png" alt="邻接表"></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> EdgeType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">EdgeNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>
    EdgeType weight<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">EdgeNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> EdgeNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">VertexNode</span> <span class="token punctuation">{</span>
    VertexType data<span class="token punctuation">;</span>
    EdgeNode <span class="token operator">*</span>firstedge<span class="token punctuation">;</span>
<span class="token punctuation">}</span> VertexNode<span class="token punctuation">,</span> AdjList<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    AdjList adjList<span class="token punctuation">;</span>
    <span class="token keyword">int</span> numVertexes<span class="token punctuation">,</span> numEdges<span class="token punctuation">;</span>
<span class="token punctuation">}</span> GraphAdjList<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li> <li><p>逆邻接表</p> <p><strong>逆邻接表</strong><br> <img src="/image/cs/dsa/readme/07_graph_adjacency_matrix_005.png" alt="逆邻接表"></p></li></ul></li> <li><p>十字链表 Orthogonal List</p> <ul><li><p>将邻接表和逆邻接表整合在一起, 可以容易找到以 Vi 为弧尾和弧头的弧</p> <p><strong>十字接表</strong><br></p> <blockquote><p>实线为邻接表, 虚线为逆邻接表</p></blockquote> <img src="/image/cs/dsa/readme/07_graph_orthogonal_list_001.png" alt="十字接表"></li></ul></li> <li><p>邻接多重表</p> <p><strong>邻接多重表</strong><br> <img src="/image/cs/dsa/readme/07_graph_adjacency_matrix_006.png" alt="邻接多重表"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ivex jvex: 与某条边依附的两个顶点在顶点表中的下标
ilink: 指向依附顶点 ivex 的下一条边
jlink: 指向依附顶点 jvex 的下一条边

理解上图, 可以将箭头指向处的jvex 替换为起点处的ivex 就可以理解了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>边集数组</p></li></ul></li></ul></li> <li><p>图的遍历</p> <ul><li><p>深度优先遍历 Depth First Search</p> <p><strong>深度优先遍历</strong><br> <img src="/image/cs/dsa/readme/07_graph_dfs_001.png" alt="深度优先遍历"></p></li> <li><p>广度优先遍历 Breadth First Search</p> <p><strong>广度优先遍历</strong><br> <img src="/image/cs/dsa/readme/07_graph_bfs_001.png" alt="广度优先遍历"></p></li></ul></li> <li><p>最小生成树 Minimum Cost Spanning Tree</p></li></ul> <blockquote><p>构造联通网的最小代价生成树</p></blockquote> <ul><li><p>Prim 算法</p></li> <li><p>Kruskal 算法</p></li></ul> <h2 id="_08-查找"><a href="#_08-查找" class="header-anchor">#</a> 08 - 查找</h2> <ul><li><p>查找概论</p> <ul><li>静态查找表 Static Search Table
<ul><li>只做查找操作</li></ul></li> <li>动态查找表 Dynamic Search Table
<ul><li>在查找过程中同时插入查找表中不存在的数据元素, 或从表中删除已存在的某个元素</li></ul></li></ul></li> <li><p>顺序表查找 Sequential Search</p> <ul><li><p>属于静态表查找</p></li> <li><p>从表中第一个(最后一个)记录开始, 逐个进行记录的关键字和给定值比较查找(就是for 循环)</p></li> <li><p>优化: 有哨兵顺序查找</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 避免了 for 循环中每次的 i 是否越界比较操作,</span>
<span class="token keyword">int</span> <span class="token function">Sequential_Search</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>   <span class="token comment">// 将a[0]设置为关键字值, 即哨兵</span>
  i <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul></li> <li><p>有序表查找</p> <ul><li>二分查找 Binary Search
<ul><li>线性表中的记录必须关键码有序, 线性表必须采用顺序存储</li></ul></li> <li>插值查找 Interpolation Search
<ul><li>根据要查的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法</li> <li>插值计算公式 <code>(key - a[low]) / a[high] - a[low]</code></li></ul></li> <li>斐波那契查找 Fibonacci Search</li></ul></li> <li><p>线性索引查找</p> <ul><li>索引, 把一个关键字与它对应的记录相关联的过程
<ul><li><p>稠密索引, 在线性索引中, 将数据集中的每个记录对应一个索引项(索引项按关键码有序排列)</p></li> <li><p>分块索引</p> <ul><li><p>对于分块有序的数据集, 将每块对应一个索引项</p></li> <li><p>块内无序, 块间有序</p> <p><strong>分块索引</strong><br> <img src="/image/cs/dsa/readme/08_001.png" alt="分块索引"></p></li></ul></li> <li><p>倒排索引 inverted index</p> <ul><li>索引表, 索引项通用结构
<ul><li>次关键码</li> <li>记录号表</li> <li>记录号表存储具有相同次关键字的所有记录的记录号</li> <li>不是由记录来确定属性值, 而是由属性值来确定记录的位置</li> <li>搜索引擎关键字检索</li></ul></li></ul></li></ul></li></ul></li> <li><p>二叉树排序</p> <ul><li>二叉排序树 Binary Sort Tree
<ul><li><p>若左子树不空, 则左子树上所有结点的值均小于它的根结构的值</p></li> <li><p>若右子树不空, 则右子树上所有结点的值均大于它的根结点的值</p></li> <li><p>它的左右子树也分别为二叉排序树</p></li> <li><p>提高查找, 插入和删除关键字的速度</p> <p><strong>二叉排序树</strong><br> <img src="/image/cs/dsa/readme/08_binary_sort_tree_001.png" alt="二叉排序树"></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul></li></ul></li> <li><p>平衡二叉树 High-Balanced Binary Search Tree (AVL 树)</p> <ul><li>二叉排序树的每一个节点的左子树和右子树的高度差最多等于 1</li> <li>可以为空树</li> <li>二叉树上结点的左子树深度减去右子树深度的值成为平衡因子BF(Balance Factor)</li> <li>最小不平衡子树
<ul><li>距离插入结点最近的, 且平衡因子绝对值大于 1 的结点为根的子树</li></ul></li> <li>平衡二叉树的实现原理
<ul><li><p>在构建二叉排序树的过程中, 每当插入一个结点时, 先检查是否因插入而破坏了树的平衡性, 若是
则找出最小不平衡子树. 在保持二叉排序树特性的前提下, 调整最小不平衡子树中各个结点之间的
链接关系, 进行相应的旋转, 使之成为新的平衡子树.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> bf<span class="token punctuation">;</span>           <span class="token comment">// 结点平衡因子</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul></li></ul></li> <li><p>多路查找树 muitl-way search tree</p> <ul><li><p>每一个结点的孩子数可以多于两个, 且每个结点处可以存储多个元素</p></li> <li><p>2-3 树</p> <ul><li>每个结点都具有两个孩子(2 结点)或三个孩子(3 结点)
<ul><li>一个 2 结点包含一个元素和两个孩子(或没有孩子)
<ul><li>左子树包含的元素小于该元素, 右子树包含的元素大于该元素</li></ul></li> <li>一个 3 结点包含一小一大两个元素和三个孩子(或没有孩子)
<ul><li>左子树包含小于叫嚣元素的元素, 右子树包含大于较大元素的元素, 中间子树包含介于两元素
之间的元素</li></ul></li></ul></li> <li>所有叶子都在同一层次上</li></ul> <p><strong>2-3树</strong><br> <img src="/image/cs/dsa/readme/08_2_3_tree_001.png" alt="2-3树"></p></li> <li><p>2-3-4 树</p> <ul><li>2, 3 结点同上</li> <li>一个 4 结点包含小中大单个元素和四个孩子(或没有孩子)
<ul><li>左子树包含小于最小元素的元素; 第二子树包含大于最小元素, 小于第二元素的元素; 第三子树
包含大于第二元素, 小于最大元素的元素; 右子树包含大于最大元素的元素</li></ul></li></ul></li> <li><p>B Tree</p> <ul><li><p>平衡的多路查找树</p></li> <li><p>结点最大的孩子数目称为 B 树的阶 order</p></li> <li><p>一个 m 阶的 B 树属性</p> <ul><li>如果根结点不是叶结点, 则其至少有两棵子树</li> <li>每个非根的分支结点都有 k-1 个元素和 k 个孩子, 其中 <code>[m/2] &lt;= k &lt;= m</code>. 每个叶子
结点 n 都有 k-1 个元素, 其中 <code>[m/2] &lt;= k &lt;= m</code></li> <li>所有叶子结点都位于同一层次</li> <li>所有分支结点包含下列信息数据 (n, A0, K1, A1, K2, ... , Kn, An ), 其中
Ki (i=1, 2, 3 ... n) 为关键字, 且 Ki &lt; K(i+1) (i=1, 2, ..., n-1),
Ai (i=0, 2, ..., n) 为指向子树根结点的指针, 且指针 A(i-1) 所指子树中所有结点的
关键字均小于 Ki, An 所指子树中所有结点的关键字均大于 Kn, n (<code>[m/2]-1&lt;=n&lt;=m-1&gt;</code>)
为关键字的个数(或 n+1 为子树的个数)</li></ul> <p><strong>B 树</strong><br> <img src="/image/cs/dsa/readme/08_b_tree_001.png" alt="B 树"></p></li> <li><p>B 树的使用案例</p> <ul><li>要处理的硬盘数据量很大时, 无法一次全部装入内存. 此时对 B 树进行调整, 使得 B 树的阶
数于硬盘存储的页面大小相匹配, 如 1001 阶(一个结点包含1000个关键字, 第一个数为关键
字个数), 高度为 2, 则可以存储超过 10 亿个关键字, 此时只要根节点常驻内存, 那么在这
棵树上, 寻找一个关键字至多需要两次硬盘的读取即可.</li></ul></li></ul></li> <li><p>B+ Tree</p> <ul><li><p>在 B 树的基础上, 出现在分支结点中的元素会被当做他们在该分支结点位置的中序后继者(叶子
结点)中再次列出. 每个叶子结点都会保存一个指向后一叶子结点的指针.</p></li> <li><p>一个 m 阶 B+ 树的属性</p> <ul><li>有 n 棵子树的结点包含有 n 个关键字</li> <li>所有的叶子节点包含全部关键字信息, 及指向含这些关键字记录的指针, 叶子结点本身依关键字
的大小自小而大顺序链接</li> <li>所有分支结点可以看成是索引, 结点中仅含有其子树中最大(或最小)关键字</li></ul> <p><strong>B+ 树</strong><br> <img src="/image/cs/dsa/readme/08_b+_tree_001.png" alt="B+ 树"></p></li></ul></li> <li><p>B+ 树的使用场景</p> <ul><li>适合带有范围的查找</li></ul></li></ul></li> <li><p>散列表查找 (哈希表)</p> <ul><li>散列结束时在记录的存储位置和它的关键字之间建立一个确定的对应关系 f, 使得每个关键字 key
对应一个存储位置 f(key).
<ul><li>f 散列/Hash 函数</li> <li>采用散列技术将记录存储在一块连续的存储空间中, 这块连续的存储空间称为散列表/Hash table</li></ul></li> <li>散列主要时面向查找的存储结构
<ul><li>适合求解问题时查找于给定值相等的记录</li> <li>不适合
<ul><li>关键字一对多的情况</li> <li>范围查找</li></ul></li></ul></li> <li>冲突不能完全避免但应尽量避免
<ul><li>两个不同的关键字计算结果相同称为冲突</li></ul></li> <li>散列函数的构造方法
<ul><li>原则
<ul><li>计算简单</li> <li>散列地址分布均匀</li></ul></li> <li>直接定址法</li> <li>数字分析法</li> <li>平方取中法</li> <li>折叠法</li> <li>除留余数法
<ul><li><code>f(key) = key mode p (p&lt;=m)</code> m 为散列表长, p 为小于等于表长的最小质数或不包含
小于 20 质因子的合数</li></ul></li> <li>随机数法
<ul><li><code>f(key) = random(key)</code></li></ul></li></ul></li> <li>处理散列冲突方法
<ul><li>开放定址法
<ul><li>一旦发生冲突, 就去寻找下一个空的散列地址</li> <li><code>fi(key) = (f(key) + di) MOD m (di = 1, 2, ...., m-1)</code> <ul><li>每次冲突, 都 +di, 可以堆积加操作, 直到没有冲突位置</li> <li>线性探测法, 每次 +1</li></ul></li> <li><code>fi(key) = (f(key) + di) MOD m (di = 1^2, -1^2, 2^2, ...., q^2, -q^2, q&lt;=m/2)</code> <ul><li>二次探测法, 负数可以双向寻找可能的位置, 平方可避免关键字聚集</li></ul></li> <li><code>fi(key) = (f(key) + di) MOD m (di = 随机数列)</code> <ul><li>随机探测法</li></ul></li></ul></li> <li>再散列函数法
<ul><li>使用多个散列函数, 每当发生散列地址冲突时, 使用另一个散列函数计算</li></ul></li> <li>链接地址法
<ul><li>将所有关键字为同义词的记录存储在一个单链表中, 即同义词子表. 散列表中只存储所有同义词
子表的头指针</li></ul></li> <li>公共溢出区法
<ul><li>将所有与当前散列表中关键字位置存在冲突的关键字存储到溢出表中</li></ul></li></ul></li></ul></li></ul> <h2 id="_09-排序"><a href="#_09-排序" class="header-anchor">#</a> 09 - 排序</h2> <ul><li><p>基本概念</p> <ul><li>排序的稳定性
<ul><li>待排序的记录中, 相等的两个记录在排序后的相对位置没有改变, 则是稳定的, 反之为不稳定的</li></ul></li> <li>内排序与外排序
<ul><li>内排序, 整个排序过程中, 待排序的所有记录全部被放置在内存中</li> <li>外排序, 由于排序的记录个数太多, 不能同时放置在内存, 整个排序需要在内外存之间多次交换数据</li></ul></li></ul></li> <li><p>冒泡排序 Bubble Sort</p> <ul><li>基本思想: 两两比较相邻记录的关键字, 如果反序则交换, 直到没有反序的记录为止</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> MAXSIZE     10</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> r<span class="token punctuation">[</span>MAXSIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span> sq_list<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print_list</span><span class="token punctuation">(</span>sq_list <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> list<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>sq_list <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubble_sort_v0</span><span class="token punctuation">(</span>sq_list <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> list<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">print_list</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;swap %d %d\n&quot;</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">print_list</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubble_sort_v1</span><span class="token punctuation">(</span>sq_list <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> list<span class="token operator">-&gt;</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">print_list</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;swap %d %d\n&quot;</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">print_list</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 flag 优化遍历过程, 当后续部分已经有序时, 不再继续遍历</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubble_sort_v2</span><span class="token punctuation">(</span>sq_list <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-&gt;</span>length <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> list<span class="token operator">-&gt;</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">print_list</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;swap %d %d\n&quot;</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">print_list</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sq_list <span class="token operator">*</span>list <span class="token operator">=</span> <span class="token punctuation">(</span>sq_list <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sq_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sq_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token operator">-&gt;</span>length <span class="token operator">=</span> MAXSIZE<span class="token punctuation">;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXSIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">bubble_sort_v1</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br></div></div></li> <li><p>选择排序</p> <ul><li>简单选择排序 Simple Selection Sort
<ul><li>通过 n - i 次关键字的比较, 从 n - i + 1 个记录中选出关键字最小的记录, 并和第
i(1 &lt;= i &lt;= n) 个记录交换之.</li></ul></li></ul></li></ul> <p>排序的部分暂时先不管, 后面会有专门的时间来学习这部分内容.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/louistin/blog.liteman/edit/master/docs/cs/dsa/数据结构与算法.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">2020-05-20 11:06:17 UTC+08:00</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/cs/design-pattern/Reactor 反应堆模式.html">
        Reactor 反应堆模式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div class="reading-progress top" data-v-21b39eda><div class="progress" data-v-21b39eda></div></div><!----></div></div>
    <script src="/assets/js/app.5aa78949.js" defer></script><script src="/assets/js/2.db8a1bd9.js" defer></script><script src="/assets/js/11.7fc433a5.js" defer></script>
  </body>
</html>
